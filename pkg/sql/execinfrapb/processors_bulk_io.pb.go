// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/execinfrapb/processors_bulk_io.proto

// Beware! This package name must not be changed, even though it doesn't match
// the Go package name, because it defines the Protobuf message names which
// can't be changed without breaking backward compatibility.

package execinfrapb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/cockroachdb/cockroach/pkg/jobs/jobspb"
	github_com_cockroachdb_cockroach_pkg_jobs_jobspb "github.com/cockroachdb/cockroach/pkg/jobs/jobspb"
	roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	github_com_cockroachdb_cockroach_pkg_security "github.com/cockroachdb/cockroach/pkg/security"
	descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// FileCompression list of the compression codecs which are currently
// supported for CSVWriter spec
type FileCompression int32

const (
	FileCompression_None FileCompression = 0
	FileCompression_Gzip FileCompression = 1
)

var FileCompression_name = map[int32]string{
	0: "None",
	1: "Gzip",
}

var FileCompression_value = map[string]int32{
	"None": 0,
	"Gzip": 1,
}

func (x FileCompression) Enum() *FileCompression {
	p := new(FileCompression)
	*p = x
	return p
}

func (x FileCompression) String() string {
	return proto.EnumName(FileCompression_name, int32(x))
}

func (x *FileCompression) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FileCompression_value, data, "FileCompression")
	if err != nil {
		return err
	}
	*x = FileCompression(value)
	return nil
}

func (FileCompression) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{0}
}

type BackfillerSpec_Type int32

const (
	BackfillerSpec_Invalid BackfillerSpec_Type = 0
	BackfillerSpec_Column  BackfillerSpec_Type = 1
	BackfillerSpec_Index   BackfillerSpec_Type = 2
)

var BackfillerSpec_Type_name = map[int32]string{
	0: "Invalid",
	1: "Column",
	2: "Index",
}

var BackfillerSpec_Type_value = map[string]int32{
	"Invalid": 0,
	"Column":  1,
	"Index":   2,
}

func (x BackfillerSpec_Type) Enum() *BackfillerSpec_Type {
	p := new(BackfillerSpec_Type)
	*p = x
	return p
}

func (x BackfillerSpec_Type) String() string {
	return proto.EnumName(BackfillerSpec_Type_name, int32(x))
}

func (x *BackfillerSpec_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(BackfillerSpec_Type_value, data, "BackfillerSpec_Type")
	if err != nil {
		return err
	}
	*x = BackfillerSpec_Type(value)
	return nil
}

func (BackfillerSpec_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{0, 0}
}

// BackfillerSpec is the specification for a "schema change backfiller".
// The created backfill processor runs a backfill for the first mutations in
// the table descriptor mutation list with the same mutation id and type.
// A backfiller processor performs KV operations to retrieve rows for a
// table and backfills the new indexes/columns contained in the table
// descriptor. It checkpoints its progress by updating the table
// descriptor in the database, and doesn't emit any rows nor support
// any post-processing.
type BackfillerSpec struct {
	Type  BackfillerSpec_Type    `protobuf:"varint,1,opt,name=type,enum=cockroach.sql.distsqlrun.BackfillerSpec_Type" json:"type"`
	Table descpb.TableDescriptor `protobuf:"bytes,2,opt,name=table" json:"table"`
	// Sections of the table to be backfilled.
	Spans []TableReaderSpan `protobuf:"bytes,3,rep,name=spans" json:"spans"`
	// Run the backfill for approximately this duration.
	// The backfill will always process at least one backfill chunk.
	Duration time.Duration `protobuf:"varint,4,opt,name=duration,casttype=time.Duration" json:"duration"`
	// The backfill involves a complete table scan in chunks,
	// where each chunk is a transactional read of a set of rows
	// along with a backfill for the rows. This is the maximum number
	// of entries backfilled per chunk.
	ChunkSize int64 `protobuf:"varint,5,opt,name=chunk_size,json=chunkSize" json:"chunk_size"`
	// The timestamp to perform index backfill historical scans at.
	ReadAsOf hlc.Timestamp `protobuf:"bytes,7,opt,name=readAsOf" json:"readAsOf"`
	// IndexesToBackfill is the set of indexes to backfill. This is populated only
	// starting in 21.1, prior to that the implied index set are those containing
	// the mutation ID of the first mutation on the table descriptor.
	IndexesToBackfill []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID `protobuf:"varint,8,rep,name=indexes_to_backfill,json=indexesToBackfill,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"indexes_to_backfill,omitempty"`
}

func (m *BackfillerSpec) Reset()         { *m = BackfillerSpec{} }
func (m *BackfillerSpec) String() string { return proto.CompactTextString(m) }
func (*BackfillerSpec) ProtoMessage()    {}
func (*BackfillerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{0}
}
func (m *BackfillerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackfillerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BackfillerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackfillerSpec.Merge(m, src)
}
func (m *BackfillerSpec) XXX_Size() int {
	return m.Size()
}
func (m *BackfillerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BackfillerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BackfillerSpec proto.InternalMessageInfo

// JobProgress identifies the job to report progress on. This reporting
// happens outside this package.
type JobProgress struct {
	JobID github_com_cockroachdb_cockroach_pkg_jobs_jobspb.JobID `protobuf:"varint,1,opt,name=job_id,json=jobId,casttype=github.com/cockroachdb/cockroach/pkg/jobs/jobspb.JobID" json:"job_id"`
	// contribution is the percent of work of the total this processor will
	// process.
	Contribution float32 `protobuf:"fixed32,2,opt,name=contribution" json:"contribution"`
	// slot is the index into the job details for this processor's completion.
	Slot int32 `protobuf:"varint,3,opt,name=slot" json:"slot"`
}

func (m *JobProgress) Reset()         { *m = JobProgress{} }
func (m *JobProgress) String() string { return proto.CompactTextString(m) }
func (*JobProgress) ProtoMessage()    {}
func (*JobProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{1}
}
func (m *JobProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JobProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobProgress.Merge(m, src)
}
func (m *JobProgress) XXX_Size() int {
	return m.Size()
}
func (m *JobProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_JobProgress.DiscardUnknown(m)
}

var xxx_messageInfo_JobProgress proto.InternalMessageInfo

type ReadImportDataSpec struct {
	Format roachpb.IOFileFormat `protobuf:"bytes,8,opt,name=format" json:"format"`
	// sample_size is the rate at which to output rows, based on an input row's size.
	SampleSize int32 `protobuf:"varint,2,opt,name=sample_size,json=sampleSize" json:"sample_size"`
	// tables supports input formats that can read multiple tables. If it is
	// non-empty, the keys specify the names of tables for which the processor
	// should read and emit data (ignoring data for any other tables that is
	// present in the input).
	//
	// TODO(dt): If a key has a nil value, the schema for that table should be
	// determined from the input on-the-fly (e.g. by parsing a CREATE TABLE in a
	// dump file) and the processor should emit a key/value for the generated
	// TableDescriptor with the corresponding descriptor ID key. If tables is
	// empty (and table_desc above is not specified), the processor should read
	// all tables in the input, determining their schemas on the fly.
	Tables map[string]*ReadImportDataSpec_ImportTable `protobuf:"bytes,9,rep,name=tables" json:"tables,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// uri is a cloud.ExternalStorage URI pointing to the CSV files to be
	// read. The map key must be unique across the entire IMPORT job.
	Uri map[int32]string `protobuf:"bytes,7,rep,name=uri" json:"uri,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// resume_pos specifies a map from an input ID to an offset in that
	// input from which the processing should continue.
	// The meaning of offset is specific to each processor.
	ResumePos              map[int32]int64 `protobuf:"bytes,14,rep,name=resume_pos,json=resumePos" json:"resume_pos,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Progress               JobProgress     `protobuf:"bytes,6,opt,name=progress" json:"progress"`
	SkipMissingForeignKeys bool            `protobuf:"varint,10,opt,name=skip_missing_foreign_keys,json=skipMissingForeignKeys" json:"skip_missing_foreign_keys"`
	// walltimeNanos is the MVCC time at which the created KVs will be written.
	WalltimeNanos int64 `protobuf:"varint,11,opt,name=walltimeNanos" json:"walltimeNanos"`
	// If set, specifies reader parallelism; 0 implies "use default".
	ReaderParallelism int32 `protobuf:"varint,13,opt,name=readerParallelism" json:"readerParallelism"`
	// User who initiated the import. This is used to check access privileges
	// when using FileTable ExternalStorage.
	UserProto github_com_cockroachdb_cockroach_pkg_security.SQLUsernameProto `protobuf:"bytes,15,opt,name=user_proto,json=userProto,casttype=github.com/cockroachdb/cockroach/pkg/security.SQLUsernameProto" json:"user_proto"`
}

func (m *ReadImportDataSpec) Reset()         { *m = ReadImportDataSpec{} }
func (m *ReadImportDataSpec) String() string { return proto.CompactTextString(m) }
func (*ReadImportDataSpec) ProtoMessage()    {}
func (*ReadImportDataSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{2}
}
func (m *ReadImportDataSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadImportDataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReadImportDataSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadImportDataSpec.Merge(m, src)
}
func (m *ReadImportDataSpec) XXX_Size() int {
	return m.Size()
}
func (m *ReadImportDataSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadImportDataSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ReadImportDataSpec proto.InternalMessageInfo

type ReadImportDataSpec_ImportTable struct {
	Desc *descpb.TableDescriptor `protobuf:"bytes,1,opt,name=desc" json:"desc,omitempty"`
	// targetCols is used to store the target columns for each existing table
	// being imported into. These are the columns for which the processor should
	// read and emit data (ignoring data for any other tables or columns outside
	// of the targetCols, that is present in the input).
	TargetCols []string `protobuf:"bytes,2,rep,name=targetCols" json:"targetCols,omitempty"`
}

func (m *ReadImportDataSpec_ImportTable) Reset()         { *m = ReadImportDataSpec_ImportTable{} }
func (m *ReadImportDataSpec_ImportTable) String() string { return proto.CompactTextString(m) }
func (*ReadImportDataSpec_ImportTable) ProtoMessage()    {}
func (*ReadImportDataSpec_ImportTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{2, 0}
}
func (m *ReadImportDataSpec_ImportTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadImportDataSpec_ImportTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReadImportDataSpec_ImportTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadImportDataSpec_ImportTable.Merge(m, src)
}
func (m *ReadImportDataSpec_ImportTable) XXX_Size() int {
	return m.Size()
}
func (m *ReadImportDataSpec_ImportTable) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadImportDataSpec_ImportTable.DiscardUnknown(m)
}

var xxx_messageInfo_ReadImportDataSpec_ImportTable proto.InternalMessageInfo

type StreamIngestionDataSpec struct {
	// PartitionAddresses locate the partitions that produce events to be
	// ingested. We don't set the casttype to avoid depending on ccl packages.
	PartitionAddresses []string `protobuf:"bytes,1,rep,name=partition_addresses,json=partitionAddresses" json:"partition_addresses,omitempty"`
	// The processor will ingest events from StartTime onwards.
	StartTime hlc.Timestamp `protobuf:"bytes,2,opt,name=start_time,json=startTime" json:"start_time"`
	// StreamAddress locate the stream so that a stream client can be initialized.
	StreamAddress string `protobuf:"bytes,3,opt,name=stream_address,json=streamAddress" json:"stream_address"`
	// JobID is the job ID of the stream ingestion job.
	JobID int64 `protobuf:"varint,4,opt,name=job_id,json=jobId" json:"job_id"`
}

func (m *StreamIngestionDataSpec) Reset()         { *m = StreamIngestionDataSpec{} }
func (m *StreamIngestionDataSpec) String() string { return proto.CompactTextString(m) }
func (*StreamIngestionDataSpec) ProtoMessage()    {}
func (*StreamIngestionDataSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{3}
}
func (m *StreamIngestionDataSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamIngestionDataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StreamIngestionDataSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamIngestionDataSpec.Merge(m, src)
}
func (m *StreamIngestionDataSpec) XXX_Size() int {
	return m.Size()
}
func (m *StreamIngestionDataSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamIngestionDataSpec.DiscardUnknown(m)
}

var xxx_messageInfo_StreamIngestionDataSpec proto.InternalMessageInfo

type StreamIngestionFrontierSpec struct {
	// HighWaterAtStart is set by the ingestion job when initializing the frontier
	// processor. It is used as sanity check by the frontier processor to ensure
	// that it does not receive updates at a timestamp lower than this field. This
	// consequently prevents the job progress from regressing during ingestion.
	HighWaterAtStart hlc.Timestamp `protobuf:"bytes,1,opt,name=high_water_at_start,json=highWaterAtStart" json:"high_water_at_start"`
	// TrackedSpans is the entire span set being watched. The spans do not really
	// represent KV spans but uniquely identify the partitions in the ingestion
	// stream. Once all the partitions in the ingestion stream have been resolved
	// at a certain timestamp, then it's safe to resolve the ingestion at that
	// timestamp.
	TrackedSpans []roachpb.Span `protobuf:"bytes,2,rep,name=tracked_spans,json=trackedSpans" json:"tracked_spans"`
}

func (m *StreamIngestionFrontierSpec) Reset()         { *m = StreamIngestionFrontierSpec{} }
func (m *StreamIngestionFrontierSpec) String() string { return proto.CompactTextString(m) }
func (*StreamIngestionFrontierSpec) ProtoMessage()    {}
func (*StreamIngestionFrontierSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{4}
}
func (m *StreamIngestionFrontierSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamIngestionFrontierSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StreamIngestionFrontierSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamIngestionFrontierSpec.Merge(m, src)
}
func (m *StreamIngestionFrontierSpec) XXX_Size() int {
	return m.Size()
}
func (m *StreamIngestionFrontierSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamIngestionFrontierSpec.DiscardUnknown(m)
}

var xxx_messageInfo_StreamIngestionFrontierSpec proto.InternalMessageInfo

type BackupDataSpec struct {
	Spans            []roachpb.Span                 `protobuf:"bytes,1,rep,name=spans" json:"spans"`
	IntroducedSpans  []roachpb.Span                 `protobuf:"bytes,2,rep,name=introduced_spans,json=introducedSpans" json:"introduced_spans"`
	DefaultURI       string                         `protobuf:"bytes,3,opt,name=default_uri,json=defaultUri" json:"default_uri"`
	URIsByLocalityKV map[string]string              `protobuf:"bytes,4,rep,name=uris_by_locality_kv,json=urisByLocalityKv" json:"uris_by_locality_kv,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	MVCCFilter       roachpb.MVCCFilter             `protobuf:"varint,5,opt,name=mvcc_filter,json=mvccFilter,enum=cockroach.roachpb.MVCCFilter" json:"mvcc_filter"`
	Encryption       *roachpb.FileEncryptionOptions `protobuf:"bytes,6,opt,name=encryption" json:"encryption,omitempty"`
	BackupStartTime  hlc.Timestamp                  `protobuf:"bytes,7,opt,name=backup_start_time,json=backupStartTime" json:"backup_start_time"`
	BackupEndTime    hlc.Timestamp                  `protobuf:"bytes,8,opt,name=backup_end_time,json=backupEndTime" json:"backup_end_time"`
	// PKIDs is used to convert result from an ExportRequest into row count
	// information passed back to track progress in the backup job.
	PKIDs map[uint64]bool `protobuf:"bytes,9,rep,name=pk_ids,json=pkIds" json:"pk_ids,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// User who initiated the backup. This is used to check access privileges
	// when using FileTable ExternalStorage.
	UserProto github_com_cockroachdb_cockroach_pkg_security.SQLUsernameProto `protobuf:"bytes,10,opt,name=user_proto,json=userProto,casttype=github.com/cockroachdb/cockroach/pkg/security.SQLUsernameProto" json:"user_proto"`
}

func (m *BackupDataSpec) Reset()         { *m = BackupDataSpec{} }
func (m *BackupDataSpec) String() string { return proto.CompactTextString(m) }
func (*BackupDataSpec) ProtoMessage()    {}
func (*BackupDataSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{5}
}
func (m *BackupDataSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupDataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BackupDataSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupDataSpec.Merge(m, src)
}
func (m *BackupDataSpec) XXX_Size() int {
	return m.Size()
}
func (m *BackupDataSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupDataSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BackupDataSpec proto.InternalMessageInfo

// RestoreDataEntry will be specified at planning time to the SplitAndScatter
// processors, then those processors will stream these, encoded as bytes in rows
// to the RestoreDataProcessors.
// This field has a subset of the importEntry struct defined in restore.
type RestoreSpanEntry struct {
	Span        roachpb.Span                 `protobuf:"bytes,1,opt,name=span" json:"span"`
	Files       []roachpb.ImportRequest_File `protobuf:"bytes,2,rep,name=files" json:"files"`
	ProgressIdx int64                        `protobuf:"varint,3,opt,name=progressIdx" json:"progressIdx"`
}

func (m *RestoreSpanEntry) Reset()         { *m = RestoreSpanEntry{} }
func (m *RestoreSpanEntry) String() string { return proto.CompactTextString(m) }
func (*RestoreSpanEntry) ProtoMessage()    {}
func (*RestoreSpanEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{6}
}
func (m *RestoreSpanEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreSpanEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RestoreSpanEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreSpanEntry.Merge(m, src)
}
func (m *RestoreSpanEntry) XXX_Size() int {
	return m.Size()
}
func (m *RestoreSpanEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreSpanEntry.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreSpanEntry proto.InternalMessageInfo

type RestoreDataSpec struct {
	RestoreTime hlc.Timestamp                      `protobuf:"bytes,1,opt,name=restore_time,json=restoreTime" json:"restore_time"`
	Encryption  *roachpb.FileEncryptionOptions     `protobuf:"bytes,2,opt,name=encryption" json:"encryption,omitempty"`
	Rekeys      []roachpb.ImportRequest_TableRekey `protobuf:"bytes,3,rep,name=rekeys" json:"rekeys"`
	// PKIDs is used to convert result from an ExportRequest into row count
	// information passed back to track progress in the backup job.
	PKIDs map[uint64]bool `protobuf:"bytes,4,rep,name=pk_ids,json=pkIds" json:"pk_ids,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *RestoreDataSpec) Reset()         { *m = RestoreDataSpec{} }
func (m *RestoreDataSpec) String() string { return proto.CompactTextString(m) }
func (*RestoreDataSpec) ProtoMessage()    {}
func (*RestoreDataSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{7}
}
func (m *RestoreDataSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreDataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RestoreDataSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreDataSpec.Merge(m, src)
}
func (m *RestoreDataSpec) XXX_Size() int {
	return m.Size()
}
func (m *RestoreDataSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreDataSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreDataSpec proto.InternalMessageInfo

type SplitAndScatterSpec struct {
	Chunks []SplitAndScatterSpec_RestoreEntryChunk `protobuf:"bytes,1,rep,name=chunks" json:"chunks"`
	Rekeys []roachpb.ImportRequest_TableRekey      `protobuf:"bytes,2,rep,name=rekeys" json:"rekeys"`
}

func (m *SplitAndScatterSpec) Reset()         { *m = SplitAndScatterSpec{} }
func (m *SplitAndScatterSpec) String() string { return proto.CompactTextString(m) }
func (*SplitAndScatterSpec) ProtoMessage()    {}
func (*SplitAndScatterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{8}
}
func (m *SplitAndScatterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitAndScatterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SplitAndScatterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitAndScatterSpec.Merge(m, src)
}
func (m *SplitAndScatterSpec) XXX_Size() int {
	return m.Size()
}
func (m *SplitAndScatterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitAndScatterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SplitAndScatterSpec proto.InternalMessageInfo

type SplitAndScatterSpec_RestoreEntryChunk struct {
	Entries []RestoreSpanEntry `protobuf:"bytes,1,rep,name=entries" json:"entries"`
}

func (m *SplitAndScatterSpec_RestoreEntryChunk) Reset()         { *m = SplitAndScatterSpec_RestoreEntryChunk{} }
func (m *SplitAndScatterSpec_RestoreEntryChunk) String() string { return proto.CompactTextString(m) }
func (*SplitAndScatterSpec_RestoreEntryChunk) ProtoMessage()    {}
func (*SplitAndScatterSpec_RestoreEntryChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{8, 0}
}
func (m *SplitAndScatterSpec_RestoreEntryChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitAndScatterSpec_RestoreEntryChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SplitAndScatterSpec_RestoreEntryChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitAndScatterSpec_RestoreEntryChunk.Merge(m, src)
}
func (m *SplitAndScatterSpec_RestoreEntryChunk) XXX_Size() int {
	return m.Size()
}
func (m *SplitAndScatterSpec_RestoreEntryChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitAndScatterSpec_RestoreEntryChunk.DiscardUnknown(m)
}

var xxx_messageInfo_SplitAndScatterSpec_RestoreEntryChunk proto.InternalMessageInfo

// CSVWriterSpec is the specification for a processor that consumes rows and
// writes them to CSV files at uri. It outputs a row per file written with
// the file name, row count and byte size.
type CSVWriterSpec struct {
	// destination as a cloud.ExternalStorage URI pointing to an export store
	// location (directory).
	Destination string             `protobuf:"bytes,1,opt,name=destination" json:"destination"`
	NamePattern string             `protobuf:"bytes,2,opt,name=name_pattern,json=namePattern" json:"name_pattern"`
	Options     roachpb.CSVOptions `protobuf:"bytes,3,opt,name=options" json:"options"`
	// chunk_rows is num rows to write per file. 0 = no limit.
	ChunkRows int64 `protobuf:"varint,4,opt,name=chunk_rows,json=chunkRows" json:"chunk_rows"`
	// compression_codec specifies compression used for exported file.
	CompressionCodec FileCompression `protobuf:"varint,5,opt,name=compression_codec,json=compressionCodec,enum=cockroach.sql.distsqlrun.FileCompression" json:"compression_codec"`
	// User who initiated the export. This is used to check access privileges
	// when using FileTable ExternalStorage.
	UserProto github_com_cockroachdb_cockroach_pkg_security.SQLUsernameProto `protobuf:"bytes,6,opt,name=user_proto,json=userProto,casttype=github.com/cockroachdb/cockroach/pkg/security.SQLUsernameProto" json:"user_proto"`
}

func (m *CSVWriterSpec) Reset()         { *m = CSVWriterSpec{} }
func (m *CSVWriterSpec) String() string { return proto.CompactTextString(m) }
func (*CSVWriterSpec) ProtoMessage()    {}
func (*CSVWriterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{9}
}
func (m *CSVWriterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVWriterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CSVWriterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVWriterSpec.Merge(m, src)
}
func (m *CSVWriterSpec) XXX_Size() int {
	return m.Size()
}
func (m *CSVWriterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVWriterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CSVWriterSpec proto.InternalMessageInfo

// BulkRowWriterSpec is the specification for a processor that consumes rows and
// writes them to a target table using AddSSTable. It outputs a BulkOpSummary.
type BulkRowWriterSpec struct {
	Table descpb.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
}

func (m *BulkRowWriterSpec) Reset()         { *m = BulkRowWriterSpec{} }
func (m *BulkRowWriterSpec) String() string { return proto.CompactTextString(m) }
func (*BulkRowWriterSpec) ProtoMessage()    {}
func (*BulkRowWriterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{10}
}
func (m *BulkRowWriterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BulkRowWriterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BulkRowWriterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BulkRowWriterSpec.Merge(m, src)
}
func (m *BulkRowWriterSpec) XXX_Size() int {
	return m.Size()
}
func (m *BulkRowWriterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BulkRowWriterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BulkRowWriterSpec proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.sql.distsqlrun.FileCompression", FileCompression_name, FileCompression_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.BackfillerSpec_Type", BackfillerSpec_Type_name, BackfillerSpec_Type_value)
	proto.RegisterType((*BackfillerSpec)(nil), "cockroach.sql.distsqlrun.BackfillerSpec")
	proto.RegisterType((*JobProgress)(nil), "cockroach.sql.distsqlrun.JobProgress")
	proto.RegisterType((*ReadImportDataSpec)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec")
	proto.RegisterMapType((map[int32]int64)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.ResumePosEntry")
	proto.RegisterMapType((map[string]*ReadImportDataSpec_ImportTable)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.TablesEntry")
	proto.RegisterMapType((map[int32]string)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.UriEntry")
	proto.RegisterType((*ReadImportDataSpec_ImportTable)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.ImportTable")
	proto.RegisterType((*StreamIngestionDataSpec)(nil), "cockroach.sql.distsqlrun.StreamIngestionDataSpec")
	proto.RegisterType((*StreamIngestionFrontierSpec)(nil), "cockroach.sql.distsqlrun.StreamIngestionFrontierSpec")
	proto.RegisterType((*BackupDataSpec)(nil), "cockroach.sql.distsqlrun.BackupDataSpec")
	proto.RegisterMapType((map[uint64]bool)(nil), "cockroach.sql.distsqlrun.BackupDataSpec.PkIdsEntry")
	proto.RegisterMapType((map[string]string)(nil), "cockroach.sql.distsqlrun.BackupDataSpec.UrisByLocalityKvEntry")
	proto.RegisterType((*RestoreSpanEntry)(nil), "cockroach.sql.distsqlrun.RestoreSpanEntry")
	proto.RegisterType((*RestoreDataSpec)(nil), "cockroach.sql.distsqlrun.RestoreDataSpec")
	proto.RegisterMapType((map[uint64]bool)(nil), "cockroach.sql.distsqlrun.RestoreDataSpec.PkIdsEntry")
	proto.RegisterType((*SplitAndScatterSpec)(nil), "cockroach.sql.distsqlrun.SplitAndScatterSpec")
	proto.RegisterType((*SplitAndScatterSpec_RestoreEntryChunk)(nil), "cockroach.sql.distsqlrun.SplitAndScatterSpec.RestoreEntryChunk")
	proto.RegisterType((*CSVWriterSpec)(nil), "cockroach.sql.distsqlrun.CSVWriterSpec")
	proto.RegisterType((*BulkRowWriterSpec)(nil), "cockroach.sql.distsqlrun.BulkRowWriterSpec")
}

func init() {
	proto.RegisterFile("sql/execinfrapb/processors_bulk_io.proto", fileDescriptor_6d46d06b67eadaca)
}

var fileDescriptor_6d46d06b67eadaca = []byte{
	// 1869 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4d, 0x53, 0x1b, 0xc9,
	0x19, 0x66, 0xf4, 0x85, 0xf4, 0xca, 0x60, 0xd1, 0x78, 0x77, 0x27, 0xa4, 0x02, 0x94, 0x76, 0x71,
	0x14, 0x6f, 0x59, 0xaa, 0xb5, 0x93, 0x2d, 0x57, 0x92, 0x5d, 0x07, 0x09, 0xc3, 0x0a, 0xef, 0xda,
	0x64, 0x64, 0x70, 0xd5, 0x56, 0x92, 0xa9, 0xd1, 0x4c, 0x23, 0xda, 0x1a, 0x4d, 0x0f, 0xdd, 0x3d,
	0xd8, 0xf2, 0x29, 0x55, 0x39, 0xe5, 0x96, 0x9f, 0x90, 0x43, 0x7e, 0x40, 0x72, 0xc8, 0x2f, 0xc8,
	0xc5, 0xc7, 0x3d, 0xee, 0x89, 0xca, 0xe2, 0x7f, 0xe1, 0x53, 0xaa, 0x3f, 0x46, 0x0c, 0x18, 0x30,
	0xc4, 0xb5, 0x17, 0x31, 0x74, 0xf7, 0xf3, 0xf4, 0xdb, 0x6f, 0x3f, 0xef, 0xc7, 0x0c, 0x34, 0xf8,
	0x7e, 0xd8, 0xc2, 0x2f, 0xb0, 0x4f, 0xa2, 0x5d, 0xe6, 0xc5, 0xfd, 0x56, 0xcc, 0xa8, 0x8f, 0x39,
	0xa7, 0x8c, 0xbb, 0xfd, 0x24, 0x1c, 0xba, 0x84, 0x36, 0x63, 0x46, 0x05, 0x45, 0xb6, 0x4f, 0xfd,
	0x21, 0xa3, 0x9e, 0xbf, 0xd7, 0xe4, 0xfb, 0x61, 0x33, 0x20, 0x5c, 0xf0, 0xfd, 0x90, 0x25, 0xd1,
	0xc2, 0x87, 0xcf, 0x68, 0x9f, 0xb7, 0xe4, 0x4f, 0xdc, 0x57, 0x7f, 0x34, 0x62, 0xc1, 0x56, 0xab,
	0xe3, 0x7e, 0x8b, 0xd0, 0xdb, 0xbb, 0x94, 0x8d, 0x3c, 0x91, 0xce, 0x7c, 0x2c, 0x77, 0xf5, 0x3d,
	0xe1, 0x85, 0x74, 0xd0, 0x0a, 0x30, 0xf7, 0xe3, 0x7e, 0x8b, 0x0b, 0x96, 0xf8, 0x22, 0x61, 0x38,
	0x30, 0x8b, 0x56, 0x2e, 0x32, 0xcd, 0xe3, 0x38, 0xdd, 0x25, 0x11, 0x24, 0x6c, 0xed, 0x85, 0x7e,
	0x4b, 0x90, 0x11, 0xe6, 0xc2, 0x1b, 0xc5, 0x66, 0xe6, 0xc6, 0x80, 0x0e, 0xa8, 0x7a, 0x6c, 0xc9,
	0x27, 0x33, 0x8a, 0x52, 0xab, 0x02, 0x4f, 0x78, 0x66, 0x6c, 0x2e, 0x1d, 0xf3, 0x62, 0xa2, 0x87,
	0xea, 0xff, 0x28, 0xc0, 0x6c, 0xdb, 0xf3, 0x87, 0xbb, 0x24, 0x0c, 0x31, 0xeb, 0xc5, 0xd8, 0x47,
	0x1b, 0x50, 0x10, 0xe3, 0x18, 0xdb, 0xd6, 0xb2, 0xd5, 0x98, 0xbd, 0x73, 0xbb, 0x79, 0x9e, 0x43,
	0x9a, 0x27, 0x71, 0xcd, 0x27, 0xe3, 0x18, 0xb7, 0x0b, 0xaf, 0x0e, 0x97, 0xa6, 0x1c, 0x45, 0x80,
	0xda, 0x50, 0x14, 0x5e, 0x3f, 0xc4, 0x76, 0x6e, 0xd9, 0x6a, 0x54, 0xef, 0xdc, 0x3c, 0xc5, 0xc4,
	0xf7, 0x43, 0x75, 0xbe, 0x27, 0x72, 0xcd, 0x1a, 0xe6, 0x3e, 0x23, 0xb1, 0xa0, 0xcc, 0x50, 0x68,
	0x28, 0x7a, 0x00, 0x45, 0x1e, 0x7b, 0x11, 0xb7, 0xf3, 0xcb, 0xf9, 0x46, 0xf5, 0xce, 0x2f, 0xce,
	0xb7, 0x46, 0xd1, 0x38, 0xd8, 0x0b, 0xa4, 0x39, 0x5e, 0x94, 0xd2, 0x28, 0x34, 0xfa, 0x0c, 0xca,
	0x41, 0xc2, 0x3c, 0x41, 0x68, 0x64, 0x17, 0x96, 0xad, 0x46, 0xbe, 0xfd, 0x81, 0x9c, 0x7e, 0x73,
	0xb8, 0x34, 0x23, 0xdd, 0xd9, 0x5c, 0x33, 0x93, 0xce, 0x64, 0x19, 0xfa, 0x18, 0xc0, 0xdf, 0x4b,
	0xa2, 0xa1, 0xcb, 0xc9, 0x4b, 0x6c, 0x17, 0x15, 0x48, 0x73, 0x56, 0xd4, 0x78, 0x8f, 0xbc, 0xc4,
	0xe8, 0x3e, 0x94, 0x19, 0xf6, 0x82, 0x55, 0xfe, 0x78, 0xd7, 0x9e, 0x56, 0xa7, 0xfc, 0x59, 0xc6,
	0x42, 0x79, 0x65, 0xcd, 0xbd, 0xd0, 0x6f, 0x3e, 0x49, 0xaf, 0xcc, 0x30, 0x4c, 0x40, 0x88, 0xc3,
	0x3c, 0x89, 0x02, 0xfc, 0x02, 0x73, 0x57, 0x50, 0xb7, 0x6f, 0x3c, 0x6a, 0x97, 0x97, 0xf3, 0x8d,
	0x99, 0x76, 0xe7, 0xcd, 0xe1, 0xd2, 0xfd, 0x01, 0x11, 0x7b, 0x49, 0xbf, 0xe9, 0xd3, 0x51, 0x6b,
	0xc2, 0x1c, 0xf4, 0x8f, 0x9f, 0x5b, 0xf1, 0x70, 0xd0, 0x7a, 0x5b, 0x68, 0xcd, 0xae, 0xa4, 0xed,
	0xae, 0x39, 0x73, 0x86, 0xff, 0x09, 0x4d, 0xef, 0xab, 0x7e, 0x0b, 0x0a, 0xf2, 0xb2, 0x50, 0x15,
	0xa6, 0xbb, 0xd1, 0x81, 0x17, 0x92, 0xa0, 0x36, 0x85, 0x00, 0x4a, 0x1d, 0x1a, 0x26, 0xa3, 0xa8,
	0x66, 0xa1, 0x0a, 0x14, 0x15, 0xbc, 0x96, 0xdb, 0x2c, 0x94, 0x4b, 0xb5, 0xe9, 0xfa, 0xbf, 0x2c,
	0xa8, 0x6e, 0xd2, 0xfe, 0x16, 0xa3, 0x03, 0x86, 0x39, 0x47, 0x7f, 0x82, 0xd2, 0x33, 0xda, 0x77,
	0x49, 0xa0, 0x54, 0x92, 0x6f, 0x6f, 0xc8, 0x63, 0x1d, 0x1d, 0x2e, 0x15, 0x37, 0x69, 0xbf, 0xbb,
	0xf6, 0xe6, 0x70, 0xe9, 0xf3, 0x4b, 0x99, 0x9d, 0x89, 0xa8, 0xa6, 0x42, 0x3a, 0xc5, 0x67, 0xb4,
	0xdf, 0x0d, 0x50, 0x03, 0xae, 0xf9, 0x34, 0x12, 0x8c, 0xf4, 0x13, 0x75, 0x67, 0x52, 0x41, 0x39,
	0xe3, 0xbc, 0x13, 0x33, 0xc8, 0x86, 0x02, 0x0f, 0xa9, 0xb0, 0xf3, 0xcb, 0x56, 0xa3, 0x98, 0xca,
	0x4f, 0x8e, 0xd4, 0x5f, 0x95, 0x01, 0x49, 0x3d, 0x74, 0x47, 0x31, 0x65, 0x62, 0xcd, 0x13, 0x9e,
	0x92, 0xf7, 0x17, 0x50, 0xd2, 0x51, 0x6a, 0x97, 0xd5, 0x85, 0x2d, 0x65, 0x2e, 0xcc, 0xc4, 0x47,
	0xb3, 0xfb, 0x78, 0x9d, 0x84, 0x78, 0x5d, 0x2d, 0x33, 0x9c, 0x06, 0x84, 0x56, 0xa0, 0xca, 0xbd,
	0x51, 0x1c, 0x62, 0xad, 0x8b, 0x5c, 0x66, 0x5b, 0xd0, 0x13, 0x4a, 0x18, 0x3b, 0x50, 0x52, 0x02,
	0xe6, 0x76, 0x45, 0x09, 0xf7, 0xde, 0xf9, 0xc2, 0x7d, 0xdb, 0x46, 0xad, 0x65, 0xfe, 0x20, 0x12,
	0x6c, 0xac, 0xb8, 0x2d, 0xc7, 0xb0, 0xa1, 0x0d, 0xc8, 0x27, 0x8c, 0xd8, 0xd3, 0x8a, 0xf4, 0x57,
	0x57, 0x22, 0xdd, 0x66, 0x44, 0x31, 0x3a, 0x92, 0x01, 0x7d, 0x0b, 0xc0, 0x30, 0x4f, 0x46, 0xd8,
	0x8d, 0x29, 0xb7, 0x67, 0x15, 0xdf, 0x6f, 0xae, 0xc4, 0xe7, 0x28, 0xf8, 0x16, 0xd5, 0x76, 0x3a,
	0x15, 0x96, 0xfe, 0x8f, 0x36, 0xa0, 0x1c, 0x1b, 0xa5, 0xd8, 0x25, 0xe5, 0xe4, 0x95, 0xf3, 0x99,
	0x33, 0xb2, 0x4a, 0xa3, 0x23, 0x05, 0xa3, 0xfb, 0xf0, 0x13, 0x3e, 0x24, 0xb1, 0x3b, 0x22, 0x9c,
	0x93, 0x68, 0xe0, 0xee, 0x52, 0x86, 0xc9, 0x20, 0x72, 0x87, 0x78, 0xcc, 0x6d, 0x58, 0xb6, 0x1a,
	0x65, 0x03, 0xf9, 0x50, 0x2e, 0xfb, 0x46, 0xaf, 0x5a, 0xd7, 0x8b, 0x1e, 0xe2, 0x31, 0x47, 0xb7,
	0x60, 0xe6, 0xb9, 0x17, 0x86, 0x32, 0xc6, 0x1f, 0x79, 0x11, 0xe5, 0x76, 0x35, 0x13, 0xc7, 0x27,
	0xa7, 0xd0, 0x1d, 0x98, 0x63, 0x2a, 0x7d, 0x6c, 0x79, 0xcc, 0x0b, 0x43, 0x1c, 0x12, 0x3e, 0xb2,
	0x67, 0x32, 0xf7, 0xfb, 0xf6, 0x34, 0xc2, 0x00, 0x09, 0xc7, 0xcc, 0x55, 0xc9, 0xd4, 0xbe, 0xbe,
	0x6c, 0x35, 0x2a, 0xed, 0x75, 0x93, 0x59, 0xbe, 0xbc, 0x5c, 0xe4, 0x62, 0x3f, 0x61, 0x44, 0x8c,
	0x9b, 0xbd, 0xdf, 0x7f, 0xbd, 0xcd, 0x31, 0x8b, 0xbc, 0x11, 0xde, 0x92, 0x6c, 0x4e, 0x45, 0x32,
	0xab, 0xc7, 0x85, 0x04, 0xaa, 0xda, 0xf9, 0x4a, 0x18, 0xe8, 0x77, 0x50, 0x90, 0x41, 0xae, 0x62,
	0xef, 0x6a, 0x79, 0xd5, 0x72, 0x14, 0x12, 0x7d, 0x02, 0x20, 0x3c, 0x36, 0xc0, 0xa2, 0x43, 0x43,
	0x6e, 0xe7, 0x96, 0xf3, 0x8d, 0x8a, 0x99, 0xcf, 0x8c, 0x2f, 0x70, 0xa8, 0x66, 0x94, 0x88, 0x6a,
	0x90, 0x1f, 0xe2, 0xb1, 0xda, 0xb5, 0xe2, 0xc8, 0x47, 0xf4, 0x08, 0x8a, 0x07, 0x5e, 0x98, 0xa4,
	0x19, 0xfe, 0x6a, 0x22, 0xcf, 0x9c, 0xc8, 0xd1, 0x34, 0xbf, 0xce, 0xdd, 0xb3, 0x16, 0x3e, 0x87,
	0x72, 0xaa, 0xd4, 0xec, 0x8e, 0x45, 0xbd, 0xe3, 0x8d, 0xec, 0x8e, 0x95, 0x2c, 0xee, 0xb7, 0x30,
	0x7b, 0x52, 0x91, 0xef, 0x42, 0xe7, 0x33, 0xe8, 0xcd, 0x42, 0xd9, 0x52, 0xc9, 0x2e, 0x5f, 0x2b,
	0x6c, 0x16, 0xca, 0x85, 0x5a, 0x71, 0xb3, 0x50, 0x2e, 0xd6, 0x4a, 0x9b, 0x85, 0xf2, 0xb5, 0xda,
	0x4c, 0xfd, 0x07, 0x0b, 0x3e, 0xea, 0x09, 0x86, 0xbd, 0x51, 0x37, 0x1a, 0x60, 0x2e, 0x13, 0xcf,
	0x24, 0x9f, 0xb4, 0x60, 0x3e, 0xf6, 0x98, 0x20, 0x72, 0xd0, 0xf5, 0x82, 0x40, 0x0a, 0x17, 0x73,
	0xdb, 0x92, 0x3e, 0x75, 0xd0, 0x64, 0x6a, 0x35, 0x9d, 0x41, 0x6d, 0x00, 0x2e, 0x3c, 0x26, 0x5c,
	0x29, 0x3d, 0xe3, 0xb9, 0x4b, 0x55, 0x8d, 0x8a, 0x82, 0xc9, 0x51, 0xf4, 0x29, 0xcc, 0x72, 0x65,
	0x4f, 0xba, 0xa3, 0xca, 0x7f, 0x95, 0x54, 0xd8, 0x7a, 0xce, 0x6c, 0x89, 0x3e, 0x99, 0x24, 0x6b,
	0x5d, 0xfa, 0x66, 0x4e, 0x24, 0x6b, 0x93, 0x72, 0xeb, 0xff, 0xb6, 0xe0, 0xa7, 0xa7, 0xce, 0xb8,
	0xce, 0x68, 0x24, 0x88, 0x69, 0x0b, 0x1c, 0x98, 0xdf, 0x23, 0x83, 0x3d, 0xf7, 0xb9, 0x27, 0x30,
	0x73, 0x3d, 0xe1, 0x2a, 0x6b, 0x8c, 0x06, 0x2f, 0x65, 0x7f, 0x4d, 0xe2, 0x9f, 0x4a, 0xf8, 0xaa,
	0xe8, 0x49, 0x30, 0x6a, 0xc3, 0x8c, 0x60, 0x9e, 0x3f, 0xc4, 0x81, 0xab, 0xab, 0x7c, 0x4e, 0xe5,
	0xa1, 0x8f, 0xce, 0x48, 0xc9, 0x99, 0x9a, 0x7e, 0xcd, 0x60, 0xe4, 0x10, 0xaf, 0xff, 0x67, 0x5a,
	0x77, 0x30, 0x49, 0x3c, 0xb9, 0x92, 0xbb, 0x69, 0xd3, 0x60, 0x5d, 0x86, 0xce, 0xb4, 0x08, 0x5f,
	0x41, 0x8d, 0x44, 0x82, 0xd1, 0x20, 0xf1, 0xaf, 0x66, 0xce, 0xf5, 0x63, 0x98, 0xb2, 0x08, 0xdd,
	0x85, 0x6a, 0x80, 0x77, 0xbd, 0x24, 0x14, 0xae, 0xcc, 0xd5, 0xfa, 0x66, 0x90, 0x71, 0x3a, 0xac,
	0xe9, 0xa9, 0x6d, 0xa7, 0xeb, 0x80, 0x59, 0xb6, 0xcd, 0x08, 0xfa, 0x8b, 0x05, 0xf3, 0x09, 0x23,
	0xdc, 0xed, 0x8f, 0xdd, 0x90, 0xfa, 0x5e, 0x48, 0xc4, 0xd8, 0x1d, 0x1e, 0xd8, 0x05, 0x65, 0xc2,
	0x97, 0x17, 0x77, 0x61, 0xc7, 0x67, 0x97, 0x59, 0x9e, 0xb7, 0xc7, 0x5f, 0x1b, 0x86, 0x87, 0x07,
	0xba, 0x88, 0xdc, 0x38, 0x3a, 0x5c, 0xaa, 0x6d, 0x3b, 0xdd, 0xec, 0xd4, 0x8e, 0x53, 0x4b, 0x4e,
	0x2d, 0x46, 0x0e, 0x54, 0x47, 0x07, 0xbe, 0xef, 0xee, 0x92, 0x50, 0x60, 0xa6, 0xba, 0x9e, 0xd9,
	0x13, 0x97, 0x9b, 0x9e, 0xff, 0x9b, 0x9d, 0x4e, 0x67, 0x5d, 0x2d, 0x3a, 0x3e, 0xd9, 0xf1, 0x98,
	0x03, 0x92, 0x45, 0x3f, 0xa3, 0xaf, 0x00, 0x70, 0xe4, 0xb3, 0x71, 0xac, 0x2a, 0xb9, 0xae, 0x07,
	0x8d, 0x33, 0x28, 0x65, 0xc9, 0x7d, 0x30, 0x59, 0xf8, 0x58, 0xfd, 0x72, 0x27, 0x83, 0x45, 0x8f,
	0x61, 0xae, 0xaf, 0x4e, 0xeb, 0x66, 0x02, 0xe8, 0x0a, 0x6d, 0xd7, 0x75, 0x8d, 0xee, 0x4d, 0xc2,
	0xe8, 0x21, 0x98, 0x21, 0x17, 0x47, 0x81, 0xa6, 0x2b, 0x5f, 0x9e, 0x6e, 0x46, 0x63, 0x1f, 0x44,
	0x81, 0x22, 0xdb, 0x86, 0x52, 0x3c, 0x74, 0x49, 0x90, 0x96, 0xfc, 0xbb, 0x97, 0xbe, 0xb3, 0xad,
	0x61, 0x37, 0x30, 0xd5, 0xbe, 0x22, 0xe3, 0x72, 0xeb, 0x61, 0x77, 0x8d, 0x3b, 0xc5, 0x58, 0x0e,
	0x9f, 0x2a, 0x31, 0xf0, 0x63, 0x95, 0x98, 0x0e, 0x7c, 0x70, 0xa6, 0x74, 0xce, 0xc8, 0xfa, 0xe7,
	0xe7, 0xe0, 0x7b, 0x00, 0xc7, 0x67, 0xc9, 0x22, 0x0b, 0x67, 0x20, 0xcb, 0x19, 0x64, 0xfd, 0x9f,
	0x16, 0xd4, 0x1c, 0xcc, 0x05, 0x65, 0x58, 0x06, 0x91, 0x26, 0xf8, 0x0c, 0x0a, 0x32, 0x0e, 0x4d,
	0x8e, 0x79, 0x47, 0x18, 0xaa, 0xa5, 0x68, 0x15, 0x8a, 0xbb, 0x44, 0xb6, 0x5d, 0x3a, 0x74, 0x57,
	0xce, 0x6a, 0xee, 0x54, 0xdd, 0x71, 0xf0, 0x7e, 0x82, 0xb9, 0x50, 0xaa, 0x4b, 0x13, 0x81, 0x42,
	0xa2, 0x9b, 0x50, 0x4d, 0x1b, 0x90, 0x6e, 0xf0, 0x42, 0x85, 0x6f, 0xda, 0x31, 0x64, 0x27, 0xea,
	0x7f, 0xce, 0xc3, 0x75, 0x63, 0xf2, 0x24, 0xf3, 0xac, 0xc3, 0x35, 0xa6, 0x87, 0xb4, 0x9a, 0xae,
	0x90, 0x1d, 0xab, 0x06, 0xa8, 0xb4, 0x74, 0x32, 0x66, 0x72, 0xef, 0x11, 0x33, 0x5d, 0x28, 0x31,
	0xac, 0xfa, 0x25, 0xfd, 0x06, 0xf5, 0xe9, 0x3b, 0x3d, 0x62, 0x5e, 0xa4, 0x86, 0x78, 0x9c, 0xb6,
	0xbe, 0x9a, 0x40, 0xf6, 0xb4, 0x46, 0xe0, 0x3a, 0x29, 0xfd, 0xf2, 0xa2, 0x72, 0x7f, 0xc2, 0x2f,
	0x17, 0x2a, 0xfc, 0x3d, 0x54, 0xf3, 0xf7, 0x1c, 0xcc, 0xf7, 0xe2, 0x90, 0x88, 0xd5, 0x28, 0xe8,
	0xf9, 0x9e, 0x10, 0xa6, 0x56, 0xfd, 0x11, 0x4a, 0xea, 0x1d, 0x2d, 0xad, 0x00, 0xf7, 0xcf, 0xb7,
	0xf4, 0x0c, 0x78, 0x6a, 0xbd, 0xb2, 0xa7, 0x23, 0x79, 0x52, 0x47, 0x68, 0xd2, 0x8c, 0x4f, 0x73,
	0xef, 0xe9, 0xd3, 0x05, 0x17, 0xe6, 0xde, 0xda, 0x0d, 0x6d, 0xc2, 0x34, 0x96, 0xaf, 0x38, 0x38,
	0xb5, 0xff, 0xd6, 0x3b, 0x3d, 0x3d, 0x09, 0x1a, 0xc3, 0x9f, 0x12, 0xd4, 0xff, 0x9a, 0x87, 0x99,
	0x4e, 0x6f, 0xe7, 0x29, 0x23, 0xa9, 0x73, 0x6e, 0xca, 0xf2, 0xc4, 0x05, 0x89, 0xf4, 0xeb, 0xb0,
	0x95, 0x69, 0x1c, 0xb2, 0x13, 0xe8, 0xe7, 0x70, 0x4d, 0x66, 0x0a, 0x37, 0x56, 0x8e, 0xd1, 0x2a,
	0x9c, 0x2c, 0x54, 0x39, 0x44, 0x4f, 0xa0, 0x2f, 0x60, 0x9a, 0x6a, 0xe5, 0xa9, 0x60, 0xa9, 0x9e,
	0x59, 0x30, 0x3a, 0xbd, 0x1d, 0x23, 0xcf, 0xd4, 0x42, 0x83, 0x39, 0x7e, 0xd1, 0x66, 0xf4, 0x39,
	0x37, 0x2d, 0x4a, 0xf6, 0x45, 0xdb, 0xa1, 0xcf, 0x39, 0xfa, 0x03, 0xcc, 0xf9, 0x74, 0x14, 0xcb,
	0xd8, 0x93, 0x7d, 0x96, 0x4f, 0x03, 0xec, 0x9b, 0xf2, 0x74, 0xc1, 0x37, 0x01, 0x19, 0x1e, 0x9d,
	0x63, 0x58, 0xda, 0x87, 0x64, 0x98, 0x3a, 0x92, 0xe8, 0x54, 0x8e, 0x2d, 0xfd, 0x48, 0x39, 0xb6,
	0xfe, 0x14, 0xe6, 0xda, 0x49, 0x28, 0x0f, 0x94, 0xb9, 0x8e, 0xc9, 0x57, 0x12, 0xeb, 0xff, 0xfe,
	0x4a, 0x72, 0x6b, 0x05, 0xae, 0x9f, 0x3a, 0x2a, 0x2a, 0x43, 0xe1, 0x11, 0x8d, 0x70, 0x6d, 0x4a,
	0x3e, 0x6d, 0xbc, 0x24, 0x71, 0xcd, 0x6a, 0xdf, 0x7e, 0xf5, 0xc3, 0xe2, 0xd4, 0xab, 0xa3, 0x45,
	0xeb, 0xbb, 0xa3, 0x45, 0xeb, 0xfb, 0xa3, 0x45, 0xeb, 0xbf, 0x47, 0x8b, 0xd6, 0xdf, 0x5e, 0x2f,
	0x4e, 0x7d, 0xf7, 0x7a, 0x71, 0xea, 0xfb, 0xd7, 0x8b, 0x53, 0xdf, 0x56, 0x33, 0x1f, 0xa2, 0xfe,
	0x17, 0x00, 0x00, 0xff, 0xff, 0xe0, 0xb4, 0x35, 0xa5, 0x35, 0x13, 0x00, 0x00,
}

func (m *BackfillerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackfillerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackfillerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IndexesToBackfill) > 0 {
		for iNdEx := len(m.IndexesToBackfill) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.IndexesToBackfill[iNdEx]))
			i--
			dAtA[i] = 0x40
		}
	}
	{
		size, err := m.ReadAsOf.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ChunkSize))
	i--
	dAtA[i] = 0x28
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Duration))
	i--
	dAtA[i] = 0x20
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *JobProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobProgress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobProgress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Slot))
	i--
	dAtA[i] = 0x18
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Contribution))))
	i--
	dAtA[i] = 0x15
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ReadImportDataSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadImportDataSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadImportDataSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.UserProto)
	copy(dAtA[i:], m.UserProto)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.UserProto)))
	i--
	dAtA[i] = 0x7a
	if len(m.ResumePos) > 0 {
		keysForResumePos := make([]int32, 0, len(m.ResumePos))
		for k := range m.ResumePos {
			keysForResumePos = append(keysForResumePos, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForResumePos)
		for iNdEx := len(keysForResumePos) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ResumePos[int32(keysForResumePos[iNdEx])]
			baseI := i
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(keysForResumePos[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x72
		}
	}
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ReaderParallelism))
	i--
	dAtA[i] = 0x68
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.WalltimeNanos))
	i--
	dAtA[i] = 0x58
	i--
	if m.SkipMissingForeignKeys {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x50
	if len(m.Tables) > 0 {
		keysForTables := make([]string, 0, len(m.Tables))
		for k := range m.Tables {
			keysForTables = append(keysForTables, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTables)
		for iNdEx := len(keysForTables) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tables[string(keysForTables[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForTables[iNdEx])
			copy(dAtA[i:], keysForTables[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(keysForTables[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	{
		size, err := m.Format.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.Uri) > 0 {
		keysForUri := make([]int32, 0, len(m.Uri))
		for k := range m.Uri {
			keysForUri = append(keysForUri, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForUri)
		for iNdEx := len(keysForUri) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Uri[int32(keysForUri[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(keysForUri[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	{
		size, err := m.Progress.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.SampleSize))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}

func (m *ReadImportDataSpec_ImportTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadImportDataSpec_ImportTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadImportDataSpec_ImportTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TargetCols) > 0 {
		for iNdEx := len(m.TargetCols) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TargetCols[iNdEx])
			copy(dAtA[i:], m.TargetCols[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.TargetCols[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Desc != nil {
		{
			size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamIngestionDataSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamIngestionDataSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamIngestionDataSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x20
	i -= len(m.StreamAddress)
	copy(dAtA[i:], m.StreamAddress)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.StreamAddress)))
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.PartitionAddresses) > 0 {
		for iNdEx := len(m.PartitionAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionAddresses[iNdEx])
			copy(dAtA[i:], m.PartitionAddresses[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.PartitionAddresses[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StreamIngestionFrontierSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamIngestionFrontierSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamIngestionFrontierSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrackedSpans) > 0 {
		for iNdEx := len(m.TrackedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrackedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.HighWaterAtStart.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BackupDataSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupDataSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupDataSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.UserProto)
	copy(dAtA[i:], m.UserProto)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.UserProto)))
	i--
	dAtA[i] = 0x52
	if len(m.PKIDs) > 0 {
		keysForPKIDs := make([]uint64, 0, len(m.PKIDs))
		for k := range m.PKIDs {
			keysForPKIDs = append(keysForPKIDs, uint64(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint64s(keysForPKIDs)
		for iNdEx := len(keysForPKIDs) - 1; iNdEx >= 0; iNdEx-- {
			v := m.PKIDs[uint64(keysForPKIDs[iNdEx])]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(keysForPKIDs[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	{
		size, err := m.BackupEndTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.BackupStartTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.Encryption != nil {
		{
			size, err := m.Encryption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.MVCCFilter))
	i--
	dAtA[i] = 0x28
	if len(m.URIsByLocalityKV) > 0 {
		keysForURIsByLocalityKV := make([]string, 0, len(m.URIsByLocalityKV))
		for k := range m.URIsByLocalityKV {
			keysForURIsByLocalityKV = append(keysForURIsByLocalityKV, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForURIsByLocalityKV)
		for iNdEx := len(keysForURIsByLocalityKV) - 1; iNdEx >= 0; iNdEx-- {
			v := m.URIsByLocalityKV[string(keysForURIsByLocalityKV[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForURIsByLocalityKV[iNdEx])
			copy(dAtA[i:], keysForURIsByLocalityKV[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(keysForURIsByLocalityKV[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	i -= len(m.DefaultURI)
	copy(dAtA[i:], m.DefaultURI)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.DefaultURI)))
	i--
	dAtA[i] = 0x1a
	if len(m.IntroducedSpans) > 0 {
		for iNdEx := len(m.IntroducedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IntroducedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RestoreSpanEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreSpanEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestoreSpanEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ProgressIdx))
	i--
	dAtA[i] = 0x18
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Files[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RestoreDataSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreDataSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestoreDataSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PKIDs) > 0 {
		keysForPKIDs := make([]uint64, 0, len(m.PKIDs))
		for k := range m.PKIDs {
			keysForPKIDs = append(keysForPKIDs, uint64(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint64s(keysForPKIDs)
		for iNdEx := len(keysForPKIDs) - 1; iNdEx >= 0; iNdEx-- {
			v := m.PKIDs[uint64(keysForPKIDs[iNdEx])]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(keysForPKIDs[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Rekeys) > 0 {
		for iNdEx := len(m.Rekeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rekeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Encryption != nil {
		{
			size, err := m.Encryption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.RestoreTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SplitAndScatterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitAndScatterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitAndScatterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rekeys) > 0 {
		for iNdEx := len(m.Rekeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rekeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Chunks) > 0 {
		for iNdEx := len(m.Chunks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chunks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SplitAndScatterSpec_RestoreEntryChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitAndScatterSpec_RestoreEntryChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitAndScatterSpec_RestoreEntryChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CSVWriterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVWriterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CSVWriterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.UserProto)
	copy(dAtA[i:], m.UserProto)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.UserProto)))
	i--
	dAtA[i] = 0x32
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.CompressionCodec))
	i--
	dAtA[i] = 0x28
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ChunkRows))
	i--
	dAtA[i] = 0x20
	{
		size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	i -= len(m.NamePattern)
	copy(dAtA[i:], m.NamePattern)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.NamePattern)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Destination)
	copy(dAtA[i:], m.Destination)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.Destination)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BulkRowWriterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulkRowWriterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BulkRowWriterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintProcessorsBulkIo(dAtA []byte, offset int, v uint64) int {
	offset -= sovProcessorsBulkIo(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BackfillerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.Type))
	l = m.Table.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.Duration))
	n += 1 + sovProcessorsBulkIo(uint64(m.ChunkSize))
	l = m.ReadAsOf.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.IndexesToBackfill) > 0 {
		for _, e := range m.IndexesToBackfill {
			n += 1 + sovProcessorsBulkIo(uint64(e))
		}
	}
	return n
}

func (m *JobProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	n += 5
	n += 1 + sovProcessorsBulkIo(uint64(m.Slot))
	return n
}

func (m *ReadImportDataSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.SampleSize))
	l = m.Progress.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Uri) > 0 {
		for k, v := range m.Uri {
			_ = k
			_ = v
			mapEntrySize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + len(v) + sovProcessorsBulkIo(uint64(len(v)))
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	l = m.Format.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Tables) > 0 {
		for k, v := range m.Tables {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovProcessorsBulkIo(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovProcessorsBulkIo(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	n += 2
	n += 1 + sovProcessorsBulkIo(uint64(m.WalltimeNanos))
	n += 1 + sovProcessorsBulkIo(uint64(m.ReaderParallelism))
	if len(m.ResumePos) > 0 {
		for k, v := range m.ResumePos {
			_ = k
			_ = v
			mapEntrySize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + sovProcessorsBulkIo(uint64(v))
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	l = len(m.UserProto)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *ReadImportDataSpec_ImportTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Desc != nil {
		l = m.Desc.Size()
		n += 1 + l + sovProcessorsBulkIo(uint64(l))
	}
	if len(m.TargetCols) > 0 {
		for _, s := range m.TargetCols {
			l = len(s)
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	return n
}

func (m *StreamIngestionDataSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PartitionAddresses) > 0 {
		for _, s := range m.PartitionAddresses {
			l = len(s)
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	l = m.StartTime.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.StreamAddress)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	return n
}

func (m *StreamIngestionFrontierSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.HighWaterAtStart.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.TrackedSpans) > 0 {
		for _, e := range m.TrackedSpans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	return n
}

func (m *BackupDataSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	if len(m.IntroducedSpans) > 0 {
		for _, e := range m.IntroducedSpans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	l = len(m.DefaultURI)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.URIsByLocalityKV) > 0 {
		for k, v := range m.URIsByLocalityKV {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovProcessorsBulkIo(uint64(len(k))) + 1 + len(v) + sovProcessorsBulkIo(uint64(len(v)))
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.MVCCFilter))
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovProcessorsBulkIo(uint64(l))
	}
	l = m.BackupStartTime.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.BackupEndTime.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.PKIDs) > 0 {
		for k, v := range m.PKIDs {
			_ = k
			_ = v
			mapEntrySize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	l = len(m.UserProto)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *RestoreSpanEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.ProgressIdx))
	return n
}

func (m *RestoreDataSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RestoreTime.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovProcessorsBulkIo(uint64(l))
	}
	if len(m.Rekeys) > 0 {
		for _, e := range m.Rekeys {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	if len(m.PKIDs) > 0 {
		for k, v := range m.PKIDs {
			_ = k
			_ = v
			mapEntrySize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SplitAndScatterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	if len(m.Rekeys) > 0 {
		for _, e := range m.Rekeys {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	return n
}

func (m *SplitAndScatterSpec_RestoreEntryChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	return n
}

func (m *CSVWriterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.NamePattern)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.Options.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.ChunkRows))
	n += 1 + sovProcessorsBulkIo(uint64(m.CompressionCodec))
	l = len(m.UserProto)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *BulkRowWriterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func sovProcessorsBulkIo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProcessorsBulkIo(x uint64) (n int) {
	return sovProcessorsBulkIo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BackfillerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackfillerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackfillerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= BackfillerSpec_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, TableReaderSpan{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadAsOf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReadAsOf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IndexesToBackfill = append(m.IndexesToBackfill, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IndexesToBackfill) == 0 {
					m.IndexesToBackfill = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IndexesToBackfill = append(m.IndexesToBackfill, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexesToBackfill", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= github_com_cockroachdb_cockroach_pkg_jobs_jobspb.JobID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contribution", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Contribution = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadImportDataSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadImportDataSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadImportDataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleSize", wireType)
			}
			m.SampleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Progress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uri == nil {
				m.Uri = make(map[int32]string)
			}
			var mapkey int32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Uri[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Format.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tables == nil {
				m.Tables = make(map[string]*ReadImportDataSpec_ImportTable)
			}
			var mapkey string
			var mapvalue *ReadImportDataSpec_ImportTable
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ReadImportDataSpec_ImportTable{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tables[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipMissingForeignKeys", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipMissingForeignKeys = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalltimeNanos", wireType)
			}
			m.WalltimeNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalltimeNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReaderParallelism", wireType)
			}
			m.ReaderParallelism = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReaderParallelism |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumePos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResumePos == nil {
				m.ResumePos = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResumePos[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProto = github_com_cockroachdb_cockroach_pkg_security.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadImportDataSpec_ImportTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desc == nil {
				m.Desc = &descpb.TableDescriptor{}
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetCols = append(m.TargetCols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamIngestionDataSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamIngestionDataSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamIngestionDataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionAddresses = append(m.PartitionAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamIngestionFrontierSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamIngestionFrontierSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamIngestionFrontierSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWaterAtStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HighWaterAtStart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrackedSpans = append(m.TrackedSpans, roachpb.Span{})
			if err := m.TrackedSpans[len(m.TrackedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupDataSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupDataSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupDataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, roachpb.Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntroducedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntroducedSpans = append(m.IntroducedSpans, roachpb.Span{})
			if err := m.IntroducedSpans[len(m.IntroducedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIsByLocalityKV", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.URIsByLocalityKV == nil {
				m.URIsByLocalityKV = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.URIsByLocalityKV[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MVCCFilter", wireType)
			}
			m.MVCCFilter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MVCCFilter |= roachpb.MVCCFilter(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &roachpb.FileEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackupStartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupEndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackupEndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PKIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PKIDs == nil {
				m.PKIDs = make(map[uint64]bool)
			}
			var mapkey uint64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PKIDs[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProto = github_com_cockroachdb_cockroach_pkg_security.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreSpanEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreSpanEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreSpanEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, roachpb.ImportRequest_File{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgressIdx", wireType)
			}
			m.ProgressIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProgressIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreDataSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreDataSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreDataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestoreTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RestoreTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &roachpb.FileEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rekeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rekeys = append(m.Rekeys, roachpb.ImportRequest_TableRekey{})
			if err := m.Rekeys[len(m.Rekeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PKIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PKIDs == nil {
				m.PKIDs = make(map[uint64]bool)
			}
			var mapkey uint64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PKIDs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitAndScatterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitAndScatterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitAndScatterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, SplitAndScatterSpec_RestoreEntryChunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rekeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rekeys = append(m.Rekeys, roachpb.ImportRequest_TableRekey{})
			if err := m.Rekeys[len(m.Rekeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitAndScatterSpec_RestoreEntryChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreEntryChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreEntryChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, RestoreSpanEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVWriterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVWriterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVWriterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamePattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamePattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkRows", wireType)
			}
			m.ChunkRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionCodec", wireType)
			}
			m.CompressionCodec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionCodec |= FileCompression(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProto = github_com_cockroachdb_cockroach_pkg_security.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulkRowWriterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulkRowWriterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulkRowWriterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProcessorsBulkIo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProcessorsBulkIo
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProcessorsBulkIo
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProcessorsBulkIo
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProcessorsBulkIo        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProcessorsBulkIo          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProcessorsBulkIo = fmt.Errorf("proto: unexpected end of group")
)
